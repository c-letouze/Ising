#include <iostream>
#include <random>
#include "xtensor/xarray.hpp"
#include "xtensor/xrandom.hpp"
#include "xtensor/xio.hpp"
#include "xtensor/xview.hpp"
#include "xtensor/xpad.hpp"

xt::xarray<int> init_simulation(int nrow, int ncol, char i)
{
	
	if (i== 'u')
	{
		xt::xarray<int> arr = xt::ones<int>({nrow, ncol});
		return arr;
	}
	else
	{
		xt::xarray<int> arr_tmp = xt::random::randint({nrow, ncol}, 0, 2);
		return 2*arr_tmp - 1;
	}	
}

double measure_magnetization(xt::xarray<int>* ptr_arr, double* ptr_param)
{
	double mag_mmt = *(ptr_param+2);
	double mean = xt::mean(*ptr_arr)();
	return mag_mmt * mean;
}

double measure_energy(xt::xarray<int>* ptr_arr, double* ptr_param)
 {
	xt::xarray<double> arr = *ptr_arr;
	int nrow = arr.shape(0);
	int ncol = arr.shape(1);
	double coupling_cst = *(ptr_param+1);
	
	xt::xarray<int> periodic = xt::pad(arr, 1, xt::pad_mode::periodic);

	xt::xarray<int> zeros_row = xt::zeros<int>({1, ncol});
	xt::xarray<int> array_up = xt::vstack(xtuple(arr, zeros_row));
	xt::xarray<int> neighb_up = xt::view(periodic, xt::range(_, -1), 
											xt::range(1, -1));
	xt::xarray<int> inter_up = xt::view(array_up*neighb_up, 
										xt::range(_, -1), xt::all());
	
	xt::xarray<int> zeros_col = xt::zeros<int>({nrow, 1});
	xt::xarray<int> array_left = xt::hstack(xtuple(arr, zeros_col));
	xt::xarray<int> neighb_left = xt::view(periodic, xt::range(1, -1), 
											xt::range(_, -1));
	xt::xarray<int> inter_left = xt::view(array_left*neighb_left, 
											xt::all(), xt::range(_, -1));
	
	xt::xarray<int> inter_total = inter_up + inter_left;
	double mean = xt::mean<double>(inter_total)();
	
	return - coupling_cst * mean;
}

double delta_hamiltonian(xt::xarray<int> arr, int i_row, int j_col, 
						double* ptr_param)
{
	double coupling_cst = *(ptr_param+1);
	
	xt::xarray<int> periodic = xt::pad(arr, 1, xt::pad_mode::periodic);
	
	int spin = periodic(i_row+1, j_col+1);
	int sum_neighbors = periodic(i_row, j_col+1) 
						+ periodic(i_row+1,j_col+2) 
						+ periodic(i_row+2, j_col+1) 
						+ periodic(i_row+1, j_col);
	
	return 2 * coupling_cst * spin * sum_neighbors;
} 

bool make_offer(xt::xarray<int>* ptr_arr, double* ptr_param)
{
	double beta = *(ptr_param);
	double coupling_cst = *(ptr_param+1);
	
	int i_row = xt::random::randint<int>({1}, 0, ptr_arr->shape(0))();
	int j_col = xt::random::randint<int>({1}, 0, ptr_arr->shape(1))();
	
	double delta_H = delta_hamiltonian(*ptr_arr, i_row, j_col, ptr_param);
	double random_nb = xt::random::rand<double>({1}, 0, 1)();
	if (std::exp(- delta_H * beta) > random_nb)
	{
		(*ptr_arr)(i_row, j_col) *= -1;
		return true;
	}
	else
	{
		return false;
	}
}
	
void evolve(xt::xarray<int>* ptr_arr, int niter, double* ptr_param)
{
	int arr_size = ptr_arr->shape(0) * ptr_arr->shape(1);
	for (int iter=0; iter<niter*arr_size; iter++)
	{
		make_offer(ptr_arr, ptr_param);
	}
	return;
}

struct phys_quantities 
{
	double energy;
	double magnetization;
	double heat_capacity;
	double mag_susceptibility;
};

phys_quantities compute_physical_quantities(xt::xarray<int>* ptr_arr, 
											int niter, double* ptr_param)
{
	xt::xarray<double> rec = xt::empty<double>({niter, 2});
	for (int iter=0; iter<niter; iter++)
	{
		evolve(ptr_arr, 1, ptr_param);
		rec(iter, 0) = measure_energy(ptr_arr, ptr_param);
		rec(iter, 1) = measure_magnetization(ptr_arr, ptr_param);
	}
	phys_quantities res;
	res.energy = xt::mean(xt::col(rec, 0))();
	res.magnetization = xt::mean(xt::col(rec, 1))();
	return res;
}

int set_correlation_time(xt::xarray<int>* ptr_arr, double* ptr_param,
							int average_time, double prec=1e-2)
{
	double delta = 2*prec;
	double mean = measure_energy(ptr_arr, ptr_param);
	int time=0;
	while (delta>prec)
	{
		phys_quantities rec = compute_physical_quantities(ptr_arr, average_time, ptr_param);
		delta = abs(mean - rec.energy);
		mean = rec.energy;
		time += average_time;
	}
	return time-average_time;
}


void print_parameters(double* ptr)
{
	std::cout << "Physical parameters:" << std::endl;
	std::cout << " - Beta factor: " << *(ptr) << std::endl;
	std::cout << " - Coupling constant: " << *(ptr+1) << std::endl;
	std::cout << " - Magnetic moment: " << *(ptr+2) << std::endl;
	return;
}

/* ************************* MAIN ******************************* */

int main(int argc, char* argv[])
{    
	
	// initialization
	std::cout << "Testing the array initialization" << std::endl;
	
    xt::xarray<int>res_u = init_simulation(3, 2, 'u');
    std::cout << "----Uniform array: " << std::endl;
    std::cout << res_u << std::endl;
    
    xt::xarray<int>res_r = init_simulation(3, 5, 'r');
    std::cout << "----Default array: " << std::endl;
    std::cout << res_r << std::endl;
    
    // physical parameters
    double k_B = 1.0;
    double temperature = 0.25;
    double beta = 1/ k_B / temperature;
    double coupling_cst = 1.0;
    double mag_moment = 1.0;
    
    double param [3] = {beta, coupling_cst, mag_moment};
    print_parameters(param);
    
    // measurement
    double magnetization = measure_magnetization(&res_r, param);
    double energy = measure_energy(&res_r, param);
    double d_energy = delta_hamiltonian(res_u, 1, 1, param);
	std::cout << "Measurements" << std::endl;
	std::cout << "---- Magnetization: " << magnetization << std::endl;
	std::cout << "---- Energy: " << energy << std::endl;
	std::cout << "---- Delta in energy: " << d_energy << std::endl;
	
	// evolution
	std::cout << res_r << std::endl;
	bool isaccepted = make_offer(&res_r, param);
	std::cout << "Make an offer... " << isaccepted << std::endl; 
	std::cout << res_r << std::endl;
	
	std::cout << "Evolve... " << std::endl;
	evolve(&res_r, 50, param);
	std::cout << res_r << std::endl;
	
	phys_quantities physical = compute_physical_quantities(&res_r, 5, param);
	std::cout << res_r << std::endl;
	std::cout << "energy: " << physical.energy << std::endl;
	std::cout << "magnetization: " << physical.magnetization << std::endl;
	
	// correlation time
	xt::xarray<int> res_3 = init_simulation(10, 10, 'r');
    int t0 = set_correlation_time(&res_3, param, 5);
    std::cout << "corr time: " << t0 << std::endl;
    
    
	
    return 0;
}
